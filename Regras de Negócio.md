# Regras de Negócio extraídas do código

| ID da Regra de Negócio | Regra de Negócio | Entradas do Usuário | Saídas do Sistema |
|---|---|---|---|
| 1 | Registro de usuário: é obrigatório fornecer nome, email e senha; email deve ser único. | { name, email, password, role? } | Em sucesso: 201 + objeto do usuário (sem a senha). Em falha: 400 + mensagem de erro ('name, email and password are required' ou 'User already exists'). |
| 2 | Login: usuário faz login com email e senha; credenciais válidas retornam token JWT e dados do usuário (sem senha). | { email, password } | Em sucesso: 200 + { token, user } onde token contém { id, email, role } e expira em 8h. Em falha: 401/400 + 'Invalid credentials' ou 'email and password required'. |
| 3 | Inicialização: se não houver usuários cadastrados, é criado um admin padrão (email: admin@hotel.local, senha: admin123). | (nenhuma) | Admin padrão criado na memória durante inicialização da aplicação. |
| 4 | Autenticação: a maioria dos endpoints exige header Authorization: Bearer <token>. Token ausente → 401; token inválido → 403. | Header Authorization: 'Bearer <token>' | Em sucesso: req.user populado com { id, email, role }. Em erro: 401/403 + { error } correspondendo à condição. |
| 5 | Autorização por papel: rotas protegidas com authorizeRole('admin') bloqueiam requisições de usuários que não tenham role === 'admin' (403). | Usuário autenticado (req.user.role) | Se role !== 'admin' → 403 + { error: 'Forbidden' }. Se admin → prossegue. |
| 6 | Criação de quarto (room): somente admin pode criar; campos obrigatórios: type, price, capacity. Novo quarto inicia como available: true. | { type, price, capacity } + token admin | Em sucesso: 201 + objeto room (id, type, price, capacity, available:true). Em falha: 400 + 'type, price and capacity are required' ou 403 se não for admin. |
| 7 | Listagem de quartos: endpoint protegido por autenticação; retorna todos os quartos armazenados na memória. | token válido | 200 + lista de quartos (cada quarto inclui disponibilidade). |
| 8 | Criação de reserva (booking): usuário autenticado cria reserva informando roomId, startDate e endDate; a sala deve existir e estar disponível. Ao criar, booking.status = 'active' e room.available passa a false. | { roomId, startDate, endDate } + token (req.user.id usado como userId) | Em sucesso: 201 + booking criado. Em falha: 400 + mensagens ('userId, roomId, startDate and endDate required', 'Room not found', 'Room not available'). |
| 9 | Listagem de reservas do usuário: retorna apenas reservas cujo booking.userId === req.user.id. (O código atual não retorna todas as reservas para admin; filtra por userId). | token válido | 200 + lista de bookings pertencentes ao usuário autenticado. |
| 10 | Cancelamento de reserva: somente o dono da reserva ou um admin pode cancelar; cancelamento muda booking.status para 'cancelled' e libera a room (available = true). | Param: id da reserva + token; req.user.id e req.user.role avaliados | Em sucesso: 200 + booking com status 'cancelled'. Em falha: 400 + mensagens ('Booking not found', 'Not allowed to cancel this booking', 'Booking already cancelled'). |
| 11 | Pagamentos: criação exige bookingId, userId e amount; novo pagamento inicia com status 'pending'. | { bookingId, userId, amount } | Em sucesso: 201 + payment (id, bookingId, userId, amount, status:'pending'). Em falha: 400 + 'bookingId, userId and amount required'. |
| 12 | Listagem de pagamentos: retorna pagamentos filtrados por userId === req.user.id. | token válido | 200 + lista de payments do usuário. |
| 13 | Atualização de status de pagamento: apenas status entre ['pending','confirmed','cancelled'] são aceitos; mudança devolve o pagamento atualizado. | Param id + { status } | Em sucesso: 200 + payment atualizado. Em falha: 400 + 'Payment not found' ou 'Invalid status'. (A rota controla o serviço; o serviço valida os estados permitidos.) |
| 14 | Persistência em memória: todos os dados (users, rooms, booking, payments) são armazenados em arrays no arquivo `src/data/memoryDB.js`. | Operações via API | Dados são voláteis: reiniciar a aplicação limpa o estado (nenhuma persistência em disco). |
| 15 | Senhas: ao registrar, a senha é armazenada como hash via bcrypt (hashSync). | password plain | Armazenamento: password hashed; ao retornar usuário em respostas, a senha é omitida. |
| 16 | Convenções de erro/status HTTP: controladores retornam 201 para criações bem-sucedidas; 400 para validações/erros de negócio; 401 para token ausente; 403 para token inválido/forbidden; mensagens de erro específicas são usadas nas respostas JSON. | Requisições inválidas/sem token/acesso não autorizado | Respostas: códigos HTTP e corpo { error: '<mensagem>' } conforme o caso. |

> Observação: as regras acima foram extraídas literalmente do comportamento implementado no código (serviços, controllers e middleware). Algumas expectativas de negócio mencionadas no README/promp (por exemplo: "admin acessa todas as funcionalidades do sistema") não estão totalmente refletidas no código atual — por exemplo, listagem de reservas está implementada para retornar apenas reservas do usuário autenticado, mesmo para admin.

***
